
<h2>Introduction

<p>
    <a href="https://www.gnu.org/software/hurd/microkernel/mach.html">GNU Mach
    is the microkernel developed for the Hurd system. It is a free (as in free
    speech) working microkernel. Despite its power, it is not very used and
    thus the documentation is lacking. This article aims to cover the principles
    of the mach kernel, and some of its API, to ease the development of any
    mach based system.

<p>
    In order to test the code examples, you will need a working installation of
    a GNU mach system. The main one is the GNU Hurd operating system. You can
    refer to my
    <a href=@{ArticleR "hacking-hurd-workflow"}>previous article
    for an installation guide. Since the code we will be writing is very low level,
    it will be architecture dependant. Our target will be the x86 32-bits
    architecture, which is what you will have if you used my previous article to
    install Hurd.

<h2>Main concepts

<h3>Execution units

<p>
    A microkernel job is to provide an interface to the hardware. That means
    abstracting the CPU and handling the execution of programs on it. Mach uses
    two abstractions for this : tasks and threads. Execution units are threads :
    they are used to store an execution, ie the value of registers. Their
    execution order is decided by Mach, which handles the interleaving of their
    executions, and splitting over multiple cores, transparently.

<p>
    There is another important device the kernel must provide an interface to,
    and that is memory. The solution used is that of virtual memory : each
    execution unit believes it has the whole memory for itself, and thus let the
    kernel handle where its memory really is, if it is swapped... But giving a
    whole memory map for every thread would be inefficient, as we might want to
    have few executions units sharing the same memory. The abstraction used for
    that is task : a task is a virtual memory map and a set of threads. A thread
    must always be part of a task, and has full access to the virtual memory of
    the task.

<p>
    Tasks also provides some more convenience utilities. For example, killing or
    pausing a task kills/pause all of its threads. A few more utilities are
    provided to handle errors. We will go back to that later. The equivalent of
    tasks in a Linux system are processus (but these are more complexes : Mach's
    tasks have no notion of users or permissions).

<h3>Interprocess communication (IPC)

<p>
    Now that we've seen how mach abstracts execution of programs, we need to look
    at the other essential aspects of a microkernel : the IPC. In other words,
    how to make tasks communicate. The abstraction is the port. A port is a
    queue of typed messages. It is manipulated through ports rights. A port right
    is an integer linked with a task that allows to enqueue and/or dequeue
    messages from the port (a bit like a file descriptor in Linux).

<p>
    So that means that the knowledge of the port right is the ability to use it.
    It is made so that another task cannot guess port rights it does not have.

<p>
    Ports rights are task specific. This means that all the threads of a task
    share the same port rights. When sending a message, a port right can be sent.
    This allow a ports to be created in a task, and then sent to other tasks.

<p>
    They are three king of port rights : send, send-once and receive. The send
    right is the ability to enqueue messages on the port. It can be copied to
    other tasks. The send-once right is the ability to enqueue only one message
    on the port. The receive right is the ability to dequeue messages from the
    port. Only one task can hold the receive right for a given port. It can be
    used to create send and send-once rights for the port, and can be transfered
    between tasks.

<p>
    Messages are dequeued in the order they are enqueued. Enqueueing a message
    will block if the port is full, and dequeueing will if it is empty. Both these
    operations can use a timeout. If multiple threads try to receive from a port
    at the same time, every message will be received only once, but which thread
    will receive which message is undefined.

<p>
    Ports right can be grouped into ports sets. This allows to wait a message
    from multiple ports, reading from the first one to be ready (it is slightly
    similar to the <code>select</code> system call in Linux).

<h3>Controlling execution

<p>
    It is possible to pause, resume and kill any thread independently, or whole
    tasks at once. When a thread is paused, it is possible access its state (ie
    the value of its registers) and change it (doing this in an unposed thread
    will cause undefined behaviours). This implies a thread cannot access its
    own state.

<p>
    Every thread and task also has an exception port. When an error is raised
    (either manually, or because of a segfault/division by zero ...), a message
    is sent to the thread exception port, or if it is null to the task exception
    port. This allows for debugging/recovering from errors.

<h2>Using the GNU mach API

<p>
    The API documentation can be found
    <a href="https://www.gnu.org/software/hurd/gnumach-doc/index.html">here
    , but since it is quite terse, I will detail the ipc mechanism and the thread
    creation through examples.

    A bit of warning : it seems the documentation is not completely up to date
    when it comes to return values. Indeed, after looking at the source code of
    Mach, it turns out some functions have more return values than what is
    described in this documentation. Just remember that all function returns
    a <code>kern_return_t</code>, which is <code>KERN_SUCCESS</code> in case of
    success, and another value in case of error. I won't dig into error handling
    other than the existence of error, so it won't bother me in the next
    examples. Also, and despite the fact that I use <code>perror</code>, Mach
    calls does not set <code>errno</code>.

<h3>A minimal IPC example

<p>
    Here I will detail how to create a port, send an integer to it and receive
    this integer from, all from the same thread. This is quite a cheap example,
    but the even basic IPC is not so trivial, so it may be interesting to focus
    on that first. You can find the code
    <a href="https://github.com/lucas8/mach-ipc/blob/master/minimal_ipc/main.c">there</a>.
    I will assume you're looking at the code when reading the following, so I will
    not write the code again here.

<p>
    First we need to create a port. As said before, a port is just an integer,
    but Mach defines an alias <code>mach_port_t</code> for this. The call for
    the creation is <code>mach_port_allocate</code>, documented
    <a href="https://www.gnu.org/software/hurd/gnumach-doc/Port-Creation.html">here
    . It expects three argument. The third one is used to return the created port.
    The first one is the current task : indeed, we said before ports are task
    specific, and thus we allocate a port for a certain task. And there is call
    just for that : <code>mach_task_self()</code>, which returns the current task.
    Finally, we precise which rights we want on the port. We will want to send
    and receive, but since we can derive send rights from receive ones, we will
    create it with receive rights, so we use the constant
    <code>MACH_PORT_RIGHT_RECEIVE</code>.

<p>
    Now we want to create utility functions to send and receive integers from a
    port. We will first focus on sending a message. Thus, what we want to create
    is a <code>send_integer</code> function, which takes a port and an integer,
    and sends it on the port.

<p>
    But we cannot send just anything on a port : message needs to have a certain
    formatting. It must starts with a <code>mach_msg_header_t</code>, then
    information about its type (either short or long). We will use short
    information so we need a <code>mach_msg_type_t</code>. And then is the
    content of the message, in our case an integer. Instead of creating buffers
    with the right size and copying structure into it, we can directly create
    our own structure with the right members.

<p>
    When sending a message, it need to have both the right header and the right
    type info. First we focus on the header. The header must have data about the
    transfer itself, rather than the message specifically. It must have the size
    of the whole message (with the header and type information) in its
    <code>msgh_size</code> field. The destination port is in <code>msgh_remote_port</code>.
    A message can also specify another port in <code>msgh_local_port</code>, which
    is often used as a reply port. In our case, we don't need it, so we set it
    to <code>MACH_PORT_NULL</code>. Finally, we need to precise which right these
    ports have in the <code>msgh_bits</code> field. We need to use the macros
    <code>MACH_MSGH_BITS_REMOTE</code> to say the given right are to apply to
    the remote port, and we use <code>MACH_MSG_TYPE_MAKE_SEND</code> to tell it
    to create send right from the receive one (remember, we created the port with
    receive rights, because it is possible to create send one from these), and to
    use them to enqueue the message.

<p>
    Then on to the type header. This header is used by receiver to determine to
    kind of data sent. Sending and receiving the message would still work without
    it, but it is necessary when sending more complex data (like port rights,
    or out of line data), so it is a good idea to learn how to set it. Most of
    the field are pretty straightforward, like <code>msgt_size</code> or
    <code>msgt_number</code>. <code>msgt_name</code> is just a classifier of data,
    mostly unnecessary, unless you send port rights to another task, so that
    Mach can update them according to the new task. <code>msgt_inline</code> tells
    whether the data is inside the message, or if their only is a pointer to the
    data in the message. This field is particularly important when you communicate
    with another task, which has another memory space, as Mach will interpret it
    and copy the data to the other task memory space, and update the pointer
    transparently. <code>msgt_deallocate</code>, in the case of an out of line,
    tells Mach to free the data from the sender memory space. Finally,
    <code>msgt_longform</code> specify whether the type header is the long one
    or none.

<p>
    Now that we've got our well formatted header, we can proceed to send it.
    The magic function doing everything (which we will also use for reception)
    is the <code>mach_msg</code> procedure. It's first argument is the message
    itself (it says it expects a pointer to a header but since the message
    must start with a header it is the same to give any of the pointer). The
    second argument precise the kind of transfer. The third one is the
    size we want to send (here we set it to the size of the message). The forth
    the size we want to receive (since we're only sending a message, we set it
    to 0). Then the port on which to receive (we're not receiving, so we set it
    to <code>MACH_PORT_NULL</code>). The timeout in case the queue is full (we
    won't use that here). And finally, the last argument can be used for certain
    modes of communication, which I didn't fully understand, so we'll not use
    that and set it to <code>MACH_PORT_NULL</code>.

<p>
    Here we are, you can now almost fully understand the <code>send_integer</code>
    procedure.

<p>
    The <code>receive_integer</code> one is much more easier, since the message
    will be fully set by the reception. Well, this is not completely true :
    <code>mach_msg</code> will use the <code>msgh_size</code> of the header to
    determine how much size there is in the message to fill. Please not this
    field may be changed according to the amount of data received.

<p>
    We can now easily use these functions on our newly created port to send and
    receive our favorite integer !

<h3>Adding threads

<p>
    The code for this project is
    <a href="https://github.com/lucas8/mach-ipc/blob/master/minimal_threads/main.c">there</a>.
    I kept the messaging utility we've seen in the previous section to test our
    new thread. This code is not completely functional : for some reason, any
    hurd system call like <code>printf</code> or <code>scanf</code> fails in
    the new thread, so we're limited to Mach IPC in it.

<p>
    Here is the standard procedure to create a working thread in Hurd : we create
    the thread, which is paused without state initially. We then set the state
    and resume the thread. Creating the thread is pretty straightforward with
    the <code>thread_create</code> function, and resuming it is as easy with
    the <code>thread_resume</code> function. Setting the state is where the
    difficulty lie.

<p>
    Indeed, a thread state is the value of its registers. This is where the
    code we're writing becomes architecture specific. Thankfully, Mach has utility
    to describe the register values. First of all, there is the
    <code>i386_THREAD_STATE_COUNT</code> which holds the number of registers to
    set, and the <code>struct i386_thread_state</code> structure which allows
    us to easily set the value of the registers.

<p>
    Now let's focus on which registers we want to set. First of all, there is
    the <code>eip</code> register which hold the pointer to the next instruction.
    This one is easy : since the new thread share the same memory space as the
    old one, we simply need to set it to the pointer to the function we want to
    execute. We then need to set the stack <code>uesp</code> and frame
    <code>ebp</code> pointer. It is sufficient to set <code>ebp</code> to zero.
    But to set <code>uesp</code> a question arise : where to we create our
    stack, and how.

<p>
    To create the stack, we simply allocate a big enough block of memory. Let's
    use this occasion to see some functionality of the virtual memory of Mach).
    I decided (more or less arbitrarily : it copies what Hurd cthread library
    does) to set the stack size to 16 pages. To find the page size, Mach defines
    a global variable <code>mach_page_size</code>, which is of 4Kb in my 32-bit
    Qemu Hurd installation. The memory is allocated with <code>vm_allocate</code>.
    The first argument is the process for which the memory must be allocated, the
    second one is used to return the pointer to the newly allocated memory, the
    third one the size we want (which may be rounded if it is not a multiple of
    a page size), and the forth one says if we care about where it is allocated
    (FALSE value, in which case it will try to allocated at the position
    specified by the second argument), or if it can allocate it anywhere.

<p>
    Once we've got our chunk of memory, there remain two things to do : set the
    right values at the top so that the function see its argument, and protect
    to bottom of the stack to detect stack overflows. This second thing is not
    necessary but it allows us to use the virtual memory protection mechanism in
    Mach. Since permissions can only be set on whole pages, we will protect
    the bottom page of the stack from both reading and writing. The function to
    do so is <code>vm_protect</code>. The first argument the process whose
    memory must be protected, the second the address of the memory, and the
    third the size (which may be rounded to a multiple of page size). According
    to my understanding, you can either set the permissions or the maximum
    permission allowed, and this is controlled by the forth argument, set to
    FALSE.

<p>
    Now that we're protected from stack overflows, we need to setup the stack
    to be able to call the function in the thread. In 32bits, all arguments
    are passed on the stack. The stack pointer of the function must point to the
    element in the stack holding the return address, and above it the arguments,
    the first one the closest to return value. More information on
    <a href="https://en.wikipedia.org/wiki/Calling_convention#x86">wikipedia</a>.
    Once the stack is ready, we can set <code>uesp</code>, and resume the thread.

<p>
    We now have an utility function to start a thread. But what happen when the
    thread ends ? We set the return value to 0, so of course it will segfault,
    but there is no good position to return to, we simply want the thread to
    end. Well Mach provides the procedure <code>thread_terminate</code>. The
    easiest way to circumvent the problem is to call it on
    <code>mach_thread_self()</code> at the end of the routine. For those of you
    who feel this solution is not satisfying because intrusive, feel free to
    create a wrapper function to launch, taking in argument the pointer to the
    routine.

<p>
    Now our system to start thread is complete. Awfully complicated, isn't it.
    Well, Hurd provide a library,
    <a href="http://hurdextras.nongnu.org/ipc_guide/mach_ipc_cthreads.html">cthreads</a>,
    allowing an easy use of threads on Mach. But that wouldn't have been fun,
    wouldn't it ?

<h3>Sieve of Eratosthenes as a Kahn thread network

<p>
    We have seen, through minimal examples, how to use ipc and thread in mach.
    Here I will propose a small exercise to put it all together.

<p>
    <a href="https://en.wikipedia.org/wiki/Kahn_process_networks">Kahn networks
    are a theoretical model of calculus : a set of deterministic units able to
    communicate. Here every unit will be a thread, communicating through ports.
    The
    <a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">Sieve of Eratosthenes
    is an algorithm to find prime numbers by filtrating out the multiples of
    every prime already found.

<p>
    The idea of our implementation is the following : one thread writes into a
    port every integer starting from 2. The main thread, every time it receives
    an integer, print it, and add between itself and the previous thread a filter
    communicating only the integers received that are not multiples of the prime
    just found. At any moment, the number of threads in the task will be the
    number of primes found more 2.

<p>
    You now have all the cards you need to make it work. Have fun ! The solution
    is
    <a href="https://github.com/lucas8/mach-ipc/blob/master/main.c">here</a>.

<h2>Conclusion

<p>
    I hope to have given you enough knowledge to understand without to much
    trouble the documentation of Mach. Still, there are a number of points left
    unexplained :
    <ul>
        <li>How to catch exception (segfaults, division by zero ...) from the
            created threads.
        <li>How to handle hardware devices.
        <li>How to create a memory manager for Hurd.
        <li>Perhaps more importantly, how to use 
            <a href="https://www.gnu.org/software/hurd/microkernel/mach/mig/gnu_mig.html">MIG</a>,
            the Mach Interface Generator, to ease the creation of communication
            through ports.
        <li>How to use the Mach debugging features.
        <li>And probably a lot more.

